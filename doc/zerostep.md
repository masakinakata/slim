# zerostepルール

次のようにコールバックを使うことでルールセットに0step属性をつけることができる。

```
{
	'$callback'(zerostep).

	R1 @@ a :- b.
}.

R2 @@ b :- c.
a.
```

上の例ではR1が0stepルール、R2が通常のルールとなる。R1はコールバックによって膜の外に移動される。そのため、アトム `a` はR1とR2の適用によって `c` になる。

## 通常実行モード

通常実行モードでは0step→1step→…と交互にルールを適用する。0stepルールを適用する際には0stepルールを適用できるだけ適用し、これ以上適用できなくなったときに1stepルールの適用を試す。

```
{
	'$callback'(zerostep).

	a :- b.
	b :- c.
}.

b :- d.
c :- e.

a.
```

上の例では、初めに `a` に対して0stepルールである `a :- b` と `b :- c` を続けて適用した後、 `c :- e` を適用して `e` を得る。0stepルールの途中で1stepルール `b :- d` が適用されることはない。

## 非決定実行モード

非決定実行モードでは通常実行モードと同様に0stepと1step交互にルールを適用するが、0stepルールの適用によってできた状態は状態空間に登録されない。それを利用すると状態空間から関心のない状態遷移を隠すことができる。

```
{
	'$callback'(zerostep).

	a(X) :- b(X).
}.

b(X) :- c(X).

a(1), a(2), a(3).
```

上の例では、0stepを使わない場合は `a(X) :- b(X)` と `b(X) :- c(X)` が非決定的に適用され、全状態数は27になる。0stepを使うとまず `a(X) :- b(X)` によって `a(1), a(2), a(3)` が `b(1), b(2), b(3)` に書き換わる。これは状態空間に登録されないので、あたかも初期状態がこうであったかのように見える。その後に `b(X) :- c(X)` を非決定的に適用し全状態数は8となる。

## 実装について

実装の詳細はコミット（94bba65）、ソースコードを見ていただくとして、要点は以下の通りである。

- LmnRulesetに0step属性を追加
- LmnReactCxtに0stepモードを追加
- task.cに0stepルールを適用不能になるまで全ての膜に再帰的に適用する処理を追加
- task.cのCOMMIT命令に0stepルールの適用処理を追加

## その他

- 多くの例題では期待通り動くことを確認しているが、膜やルールセットの移動、プロセス文脈などが絡んだ場合の挙動は調査していない。
- 現在の仕様ではメモリリークバグがある。修正案はプルリクエスト#47を参照。
- 0stepを使わないときでも全ての膜のルールセットを列挙するので、その分コストがかかる。
- 意味論等の整備はしていない。
